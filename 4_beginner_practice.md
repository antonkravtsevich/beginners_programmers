# Начальная практика

Самым первым практическим занятием в большинстве учебных материалов, курсов и т.д. является установка ПО, необходимого для учебных целей. Мы это уже, к счастью, запилили, так что с чистой душой переходим к самому программированию.

## Структура кода

Различные языки для объединения кода в блоки используют самые разнообразные способы. К примеру, на C++ блок кода (функция) выделяется вот так:

```c
int main()
{
    cout << '1' << endl;
    cout << '2' << endl;
    cout << '3' << endl;
}
```

Здесь первая строка - заголовок функции, а код, заключенный в фигурные скобки, является отдельным структурным блоком.
Плюс такого способа - облегчение отладки. В большинство редакторов исходного кода встроена автоматическая проверка закрытых скобок, и если вы где-то упустили закрывающуюся скобку - редактор вам об этом напомнит.

Минусом является разнообразие вариантов, с помощью которых можно написать данный код. 
К примеру, тот же код может быть отформатирован следующим образом:

```c
int main() {
    cout << '1' << endl;
    cout << '2' << endl;
    cout << '3' << endl;
}
```

Или вообще

```c
int main() {
cout << '1' << endl;
cout << '2' << endl;
cout << '3' << endl;}
```

Компилятору, по сути, без разницы - для него отступы и переносы не важны. А вот для нормальной возможности читать код это все очень важно. Именно поэтому каждая команда (нормальная команда) для проекта определяет так называемый **"code convention**" - соглашение о стиле написания исходного кода, в котором определяется, как должен выглядеть код - как ставятся отступы, как именуются переменные, куда и как переносятся фигурные скобки и т.д. и т.п.

Разработчики Python пошли чуть дальше, частично объединив оформление и выделение блоков кода. 

Блок кода на Python выделяется с помощью **отступов**. К примеру, функция в python выглядит следующим образом:

```python
def main():
    print('1')
    print('2')
    print('3')
```

Перед каждой функцией `print()` расположено **4 пробела**. Эти 4 пробела и являются отступом, который означает, что все эти функции **находятся в одном логическом блоке**. VS Code, к слову, автоматически конвертирует таб в четыре пробела, тем самым избавляя вас от незавидной задачи нажимать на пробел 4 раза перед каждой вложенной в блок строкой кода.

Все параметры оформления кода на языке Python описаны в едином стандарте форматирования кода, называемом [PEP8](https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html). Можете полистать, если интересно.

Более подробно на функциях мы остановимся попозже, а сейчас перейдем к долгожданной практике.

## Первая серьезная программа

Помните, мы уже писали программу, которая выводила на экран строку `Hello world!`? Это было довольно круто, но, к сожалению, программа эта довольно глупая. Поэтому мы напишем более умную программу, с помощью которой вы поймете такие базовые вещи, как типы данных и взаимодействие с пользователем.

Если быть более точным - мы напишем чат-бота. 

Написать его очень просто:

```python
print('Привет, пользователь!')
```

Функция `print()`, как вы уже, наверное, поняли, отвечает за вывод на экран какой-либо строки.

Все, наш чат-бот готов. При запуске он говорит с нами! Поздравляю, вы великолепны!

Но если вас не покидает смутное ощущение, что получившийся чат-бот несколько, мягко говоря, тупой - что-ж, да, так и есть. Говорить-то он говорит, но только одной фразой. Да еще и обращается к нам как-то очень общно, без персонализации. Давайте это поправим.

## Переменные
Переменные - очень важная часть любой программы. В переменных хранятся промежуточные значения, необходимые для полноценной работы кода. В общем случае, уже описанном мной в предыдущей главе, переменную можно представить как пустую емкость, в то время как значение переменной - ее содержимым. 

Добавим в программу переменную, содержащую ваше имя, чтобы сделать чат-бот более персонализированным.

```python
name = 'Антон'

print('Привет, ' + name + '!')
```

Как вы видите, с переменными можно производить различные действия. В данном случае, мы **склеиваем** строку, состоящую из трех частей - `'Привет, '`, переменной `name`, хранящей строку с именем, и `!`.

Во время операций над переменными используются **значения переменных**. То бишь, нет никакой разницы между 

`'Привет, ' + name + '!'`

и

`'Привет, ' + 'Антон' + '!'`

В зависимости от типа переменных, используемых в операции (такие переменные называются крутым словом **операнды**, пришедшим из математики), операции, обозначаемые одним и тем же символом в зависимости от типа операндов могут совершать различные действия.

Возмем для примера строки и числа:

```bash
In [1]: 1 + 1
Out[1]: 2

In [2]: 'Антон' + 'Антон'
Out[2]: 'АнтонАнтон'
```

Для чисел символ `+` означает арифметическое сложение, для строк - склеивание (данная операция так же называется **конкатенацией**)

То же самое и с симовлом `*`:

```bash
In [3]: 2 * 3
Out[3]: 6

In [4]: 'Антон' * 3
Out[4]: 'АнтонАнтонАнтон'
```

Для чисел он обозначает арифметическое умножение, для строк - **мультипликацию**. Склеивает строку с самой собой столько раз, сколько указано во втором операнде.

Но что если мы попробуем сложить, к примеру, строку с числом? Это ведь разные типы. Как поступит Python?

```bash
In [5]: 'Антон' + 1
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-5-e5e89c29ab99> in <module>()
----> 1 'Антон' + 1

TypeError: must be str, not int
```

В таком случае мы получим `TypeError` - ошибку типов данных. Python не понимает, какого хрена мы творим и почему пытаемся сложить строку с числом, о чем нам и сообщает.

Тем не менее, иногда Python оказывается достаточно умным, чтобы **перевести значение из одного типа в другой без прямого на то указания** - это называется **неявное приведение типов**. О том, почему, зачем и каким образом это происходит, я остановлюсь чуть позже.

Итак, теперь наш прогрессивный чат-бот обращается к вам по имени.

Но что, если ваша судьба повернула не туда, и по какой-то невероятно ужасной причине вас зовут не Антон?

В таком случае вам остается только посочувствовать. Ну а еще добавить в программу немного интерактивности.

## Взаимодействие с пользователем

вам, наверное, знакома ситуация, когда ваш собеседник только говорит, и вообще не хочет вас слушать. В таком случае и разговаривать с ним не очень-то и хочется. На данный момент наш чат-бот является таким же самовлюбленным гадом, и никто вам за него денег не заплатит. Так что давайте добавим ему немного участия и научим поддерживать диалог. Для начала, в качестве жеста доброй воли, научим его спрашивать ваше имя.

Во многих языках ввод данных является не самой простой (для начинающего) штукой, в Python, к счастью, с этим проще.

Вот как он выглядит:

```python
name = input('Как тебя зовут? ')
```

Все.

В скобках, кстати, указывается текст, который будет выведен перед вводом текста.

Целиком наш чат-бот стал выглядеть следующим образом:

```python
name = input('Как тебя зовут? ')

print('Привет, ' + name + '!')
```

Функция `input()` останавливает программу и ждет, пока пользователь не введет какую-нибудь инфу и не нажмет Enter. Затем строка, введенная пользователем, присваивается переменной, и программа продолжает выполение.

Запустите код, ответьте на вопрос бота и получите невероятно персонализированный ответ!

## Нелинейность

Не смотря на невероятный по масштабу интеллект нашего бота, на данный момент он действует довольно линейно. Давайте добавим нелинейности. Пускай бот проверяет, зовут ли вас Антон, если да - поздравляет вас с этим невероятным достижением, а если нет - сообщает о вашей печальной судьбе.

Для создания условия в Python используется **условный оператор if**. Выглядит он следующим образом:

```python
if statement:
    do_something()
else:
    do_something_else()
```

Работает он очень просто - проверяет, является ли условие `statement` истиной. Как он это делает? Для того, чтобы ответить на этот вопрос, нам нужно погрузиться немного глубже и рассказать о еще одном типе данных.

### Тип данных Boolean

Тип данных Boolean является одним из самых простых, и при этом одним из самых важных типов данных. В переводе `Boolean` означает "логический", что, в общем-то, всецело отображает его суть.

Boolean может хранить только два значения:

- `True` - истина (правда, логический 1, существование знаения)
- `False` - ложь (неправда, логический 0, отсутствие значения)

Зачем этот тип данных нужен? В основном, для самых разнообразных условий. Как и прочие языки, python содержит кучу **оперторов сравнения (логических операторов), позволяющих сравнить два операнда**. К примеру, 
 - `==` - проверка на равенство (**не путать с `=` - присвоение значения!**) 
 - `>` - больше
 - `<` - меньше
 - `>=` - больше либо равно
 - `<=` - меньше либо равно
 - `!=` - не равно

 ...и вроде бы все. 

Но не будь Python Python'ом, если бы в нем не существовала возможность написать эти операторы более человеческим языком. К примеру, выражение `x != y` можно переписать как `x is not y`. Мы типа спрашиваем у Python `x это же не y, так?`. Обалденный язык, я с него фигею просто.

Итак, зачем нужны все эти операторы сравнения? Дело в том, что с помощью операторов сравнения **мы можем что-то сравнить**. Как неожиданно. В результате своей работы операторы сравнения возвращают значение с типом данных Boolean. Если предыдущее предложение не до конца понятно - для наглядности представим, что оператор сравнения - это какое-то наше утверждение, и Python отвечает нам, является оно истинным или ложным. К примеру,

```bash
In [1]: 1 == 1
Out[1]: True

In [2]: 1 == 2
Out[2]: False

In [3]: 1 != 1
Out[3]: False

In [4]: 1 > 2
Out[4]: False

In [5]: 1 >= 1
Out[5]: True

In [6]: 1 < 2
Out[6]: True
```

И так далее.

### Так как же работает if?

С помощью операторов сравнения мы делаем какое-то утверждение. С помощью интерпретатора Python это утверждение проверяется, и на его место в операторе if, так сказать, подставляется значение `True` или `False` в зависимости от того, является ли наше утверждение истинным или ложным. Если утверждение истинно - выполняется блок кода после оператора if. Если ложно - выполняется блок кода после оператора else.

Таким образом, схема работы оператора if выглядит следующим образом:

```python
if условие:
    выполняется если условие истинно
else:
    выполняется если условие ложно
```

Наглядный пример:

```bash
In [8]: if 1 == 1:
   ...:     print('Конечно 1=1, ты что, совсем штоли?')
   ...: else:
   ...:     print('1 не равен 1, мир - это ложь, реальность - иллюзия, Вселеная - голограмма, все существует лишь в твоем воображении!')
   ...:     
Конечно 1=1, ты что, совсем штоли?
```

### Возвращаемся к изначальной задаче

Как вы помните, нам необходимо проверить, является ли собеседник чат-бота Антоном. Делается это очень просто:

```python
name = input('Как тебя зовут? ')

if name == 'Антон':
    print('О, ну наконец-то, хоть один Антон!')
else:
    print(name+', жаль сообщать это, но ты не Антон. Но я все равно продолжу беседу.')
```

Поздравляю, ваш бот стал настолько развитым, что научился вам грубить. 

## Вместо заключения 

На этом первая практическая часть закончена. Надеюсь, вы достаточно насладились общением со своим чат-ботом и готовы к новым свершениям. 

Вот основные моменты, которые необходимо запомнить:

> Для выделения логических блоков в Python используются отступы в 4 пробела

> Переменные позволяют хранить значения, используемые в процессе работы программы. Для вывода содержимого переменной на экран используется функция `print()`, для ввода - функция `input()`

> Для создания нелинейности используется **условный оператор if**

> Для сравнения значений переменных используются **операторы сравнения**, результатом работы которых является переменная типа Boolean

> Boolean - логический тип, позволяющий хранить значения True (истина) и False (ложь)

## Домашка!

Да, теперь у нас будет домашка. Звучит она следующим образом:

Сделайте так, чтобы бот спрашивал ваш возраст и говорил вам, в каком году вы родились. 

> ***Подсказка***: не забывайте, что результатом работы функции `input()` является строка. Че с этим делать, вам предстоит узнать самостоятельно. 

Постарайтесь не сверять решения, пока окончательно не зайдете в тупик, и не забывайте самое главное правило программиста, которое я вывел однажды часам к четырем утра во время написания диплома: **В гугле есть почти все. Если вы что-то не нашли - скорее всего, вы не так ищете**. 

<u>**Готовые решения заливайте на GitHub и присылайте ссылку на файл с решением в Slack.**</u>

До следующей части, и да прибудет с вами сила!