<p style="text-align: right;">
<i>Сидит программист, <br>
программу дебажит полночи. <br>
Восходит солнце. <br></i>
 - Омар Хаям
<p>

# Немного истории

Сложно начинать говорить о языках, не ссылаясь на историю их развития. Языки программирования, как и прочие изобретения человека, претерпевали некоторые изменения в течении своего развития. Единственным отличием их пути от пути других важных штук (типа колеса, огня или электричества) является весьма короткий временной промежуток - история языков занимает не больше шестидесяти лет. По крайней мере тех языков, которые и понимаются под современным термином "язык программирования". Я не буду вдаваться в алгоритмы, к примеру, автоматизированных ткацких станков, потому что не помню точных дат и не считаю их важной деталью в нашем обучении. Так что начну я уже с ЭВМ.

## Машинные языки. Темный век железа

ЭВМ (электронно-вычислительные машины) физически устроены так, чтобы изменять свое поведение (проводить какие-либо определенные вычисления) под влиянием внешних команд. Командами этими, на самом близком к железу уровню, явлются перепады напряжения - логические 0 и 1. Вместе 0 и 1 образуют так называемую двоичную систему счисления, на основе которой вся цифровая вычислительная техника и работает. Таким образом, все команды для управления ЭВМ изначально представляли собой огромную последовательность нулей и единиц. Это было крайне неудобно по двум причинам:

 - Было крайне просто допустить ошибку, которая, понятное дело, приводила по итогу к неправильной работе программы;
 - Такие программы писались для конкретных устройств, обладающих разной **архитектурой**, и, таким образом, являлись **непереносимыми**. Не в том плане, что их никто терпеть не мог, а в том плане, что нельзя было использовать программы, написанные для одной ЭВМ, в другой ЭВМ. 

В общем, труд программиста в те годы был нудным, монотонным и очень часто приводил к ошибкам.
Однако программисты были бы не программистами, если бы лень не победила трудолюбие и они не пришли бы к выводу, что писать огромные последовательности нулей и единиц это конечно весело, но свободные вечера с возможностью сходить в бар и потусить с друзьями это намного лучше. Так что умные дядьки собрались вместе и придумали такую штуку, как ассемблер.
> Ассемблер - программа, принимающая на вход код, написанный на языке ассемблера, и генерирующий на его основе двоичный код, обрабатываемый машиной.

Ассемблер позволил заменить незапоминающиеся двоичные последовательности на так называемые "мнемонические команды". К примеру, для сложения двух чисел раньше программистам приходилось писать 10110110, теперь же они обходились простой командой add. 
Таким образом, хотя бы одну проблему ассемблер исправил - теперь программы стали выглядеть более понятными для человека. Проблемы с переносимостью, к сожалению, так и не были исправленны, но по крайней мере вечера стали посвободнее, так как разработка стала намного быстрее и удобнее.

Удобство ассемблера, конечно, вещь достаточно спорная. На фоне двоичных кодов он, разумеется, обрел огромную популярность, однако неподготовленные люди при попытках понять, как писать на нем программы, спустя пару часов начинали биться в истерике и кровоточить глазами. В общем, для выхода программирования на массовый рынок требовалось что-то покруче. И этим чем-то стали высокоуровневые языки программирования.

## Первый высокоуровневый язык и первый компилятор. 

Ассемблер, не смотря на большие проблемы с его пониманием у 95% людей, своей актуальности не потерял - он все еще используется там, где человеку приходится (по долгу службы ли, или по врожденному стремлению к подобным извращениям) работать на уровне, крайне близком к железу - программировать микроконтроллеры, писать прошивку\драйвера и т.д. и т.п. Однако программист массовый никогда этих извращений с железом не поймет, потому что на страже его лени стоит компилятор\интерпретатор, анализатор и IDE, которые в комплексе значительно облегчают его работу.

Появилась вся эта радость, благодаря которой куча народа сейчас зарабатывает кучу денег, а любой школьник может смотреть прохождения майнкрафта на ютубе, в 50-х годах. Именно тогда умные дядьки из IBM, крупнейшего на то время производителя ПК, подключили все свои математические мозги и по итогу родили то, что стало настоящим прорывом - первый высокоуровневый язык под названием Fortran. А так же компилятор к нему.

Почему высокоуровневый язык стал таким большим прорывом? Да потому, что программисты наконец-то смогли оторваться от железа. Нет, разумеется, им все еще надо было иметь какое-то представление о том, что вообще происходит внутри машины (как, к примеру, работает память), но это не шло ни в какое сравнение с уровнем знаний, необходимых для разработки на ассемблере. А самым большим плюсом стала **аппаратная независимость**
> Программный код, написанный на языке Fortran, мог быть перенесен на любую систему, скомпилирован на ней, и превращен в работающую программу.

К слову, на данном этапе важно понять разницу между программным кодом (то, что мы пишем) и программой (то, что запускается и чета делает). Для языков уровня ассемблера разница была небольшой - программный код одновременно являлся и прямыми инструкциями к компьютеру, таким образом, этот самый программный код мог быть сразу же запущен без каких-либо промежуточных действий. В случае же с высокоуровневым языком программный код перед запуском необходимо **скомпилировать**
> Компиляция - процесс, в ходе которого код на высокоуровневом языке превращается в машинный код (иногда - в ассемблерный). 

Перед выполнением компиляции программный код пропускается через так назывемый **синтаксический анализатор**, благодаря которому большнство ошибок отлавливается еще до начала компиляции.

## Структурное программирование.

Фортран оказался просто пипец каким популярным. Код для тех времен был прост и понятен, а небольшие программы не требовали ничего сверх его возможностей. Не смотря на появление переносимости и удобство разработки программы на Фортране оставались все теми же наборами команд, пусть и более удобными для понимания. Однако программисты хотели писать все более сложные программы, Фортран для этого оказывался неудобен, так как увеличение нечитаемости программы на этом языке происходило прямо пропорционально увеличеснию ее объема, а фразы "Амбиции - враг успеха" тогдашние разработчики еще, скорее всего, не знали. А еще им очень не нравился тот факт, что IBM со своим языком постепенно подгребает под себя весь рынок ПО и ПК. Вот и решили другие умные ребята, на этот раз - из Европы, собраться вместе да запилить язык получше. И так хорошо и удачно собрались, что из этого получилась аж недельная конференция в Швейцарской высшей технической школе, в Цюрихе. В ходе которого они и придумали новый язык под названием Алгол, а вместе с ним - и концепцию, которая используется до сих пор, и причем очень успешно. А назвали они эту концепцию структурным программированием.

Код Фортрана, по сути, представлял собой просто набор команд без определенной структуры. Они выполнялись последовательно и занимали очень много места. Создатели же структурного программирования решили, что это конечно прикольно, но структурировать хаос - это тоже довольно здорово. Ну и, собственно, взяли они да и структурировали его, превратив программный код в набор вложенных друг в друга блоков. Таким образом, код из первозданного хаоса превратился в нечто удобное для обозрения. Выделения отдельных участков кода в так называемые **подпрограммы** позволило использовать единожды написанный код в любом месте программы вместо того, чтобы каждый раз его повторять. 
> Таким образом, в программировании впервые появилась возможность **абстрагироваться от реализации** - зная, что делает подпрограмма, программист мог вызвать ее, не запариваясь о том, **как** она это делает. 

Все это, разумеется, значительно облегчило процесс разработки ПО. Абстракция и по сей день играет в нем огромную роль. 
Но и таких ухищрений по итогу оказалось недостаточно. Программисты хотели писать все больше и больше, программы становились все более и более непонятными, а желание разработчиков расфигачить о стену мониторы - все сильнее и сильнее. С этим надо было что-то делать.

## Объектно-ориентированное программирование.

Именно в этот момент (в 1980-х, если быть точным) на сцену, словно Испанская инквизиция, которую никто никогда не ждет, ворвалась новая парадигма - объектно-ориентированное программирование. Парадигма эта стала настолько далекой от железа, насколько это было вообще в те годы возможно, и оперировала следующими понятиями:

 - Класс
 - Объект

Класс - это структура данных, содержащая не только переменные, но и подпрограммы (сменившее имя на "методы"). Объект же - это экземпляр класса.
Если говорить понятным языком, то `Мебель` - это класс, `количество_ножек` и `цвет` - это переменные, `сколько_ножек` и `перекрасить` - это методы, а `Стул` - это объект.
Короче говоря,
> Программа на объектно-ориентированном языке, решая какую-то задачу, описывает часть мира, относяющуюся к этой задаче.

Чтобы посчитать, сколько в комнате трехногих красных стульев, вам сперва необходимо создать класс, описывающий комнату, создать его объект (к примеру, гостинную), затем - класс, описывающий стулья (да и мебель в целом), затем создать экземпляры этого класса - стулья, пару столов и, может быть, шкаф, засунуть все эти объекты мебели в объект комнаты, а уже потом манипулировать этими объектами (лазить по комнате и смотреть, какие из них красные и трехногие). 

Для задачи со стульями этот подход кажется избыточным, но в программах, переваливающих за 100 000 строк, подобная модульность является ангелом-хранителем.
Основным плюсом подобных программ стала возможность тестировать (а соответственно, и искать ошибки, если они есть) все классы по отдельности. Изменения в одном классе никак не затрагивали работу других классов, что позволило создать **новый уровень абстракции** - еще более крутой, чем в структурном программировании.

## Вместо заключения

Парадигмы в программировании бывают самые разные. Помимо описанных мной существуют, к примеру, функциональные языки, оперирующие чистыми функциями (в математическом понимании) вместо подпрограмм. Долгое время они являлись уделом академиков и бородатых математиков-программистов, но теперь уверенно выходят в мир реальной разработки, продемонстрировав парочку очень любопытных плюсов. 

Зачем я все это написал? Для того, чтобы донести одну простую мысль - за полвека (окей, 65 лет) языки программирования прошли огромный путь. Вещи, которые сейчас кажутся нам очевидными и привычными, когда-то были крайне вдохновляющими инновациями. Эти же вещи в какой-то момент времени, в будущем, могут уступить место чему-то другому - чему-то лучшему. Поэтому нет никакого смысла привязываться к конкретному языку и строить свою карьеру всецело на нем одном. Лучшее, что может изучить программист - это то, как развивались языки, **чем они отличаются друг от друга**, и какие отличительные особенности языка могут пригодиться для решения определенной задачи.  

Учить языки программирования намного проще, имея определенный багаж. Чем больше вы будете знать - тем больше, при изучении нового языка, вы будете концентрироваться на его отличиях от предыдущих, и это существенно упростит процесс и позволит вам быть более мобильным в работе. 
