# Структуры данных, че с ними делать и с какой целью 

Прошло аж целых полторы недели с момента предыдущей лекции, вы все поднабрались опыта с самоучителем, поэтому самое время переходить к более серьезным темам. А именно - к структурам данных. А так же рассказать немного о их практическом использовании.

Не будем тянуть кота за интересности, а сразу же нырнем с головой во всю эту фигню.

## Зачем структурировать данные?

Переменные - очень удобная штука. Они хранят значения и позволяют эти значения использовать и изменять. Но представьте, что данных у вас не просто много, а огромная куча. Для примера возьмем немного банальную задачу - список дел на сегодня. Ну или вообще на любой день. Каким образом его хранить?

Для наглядности и поднятия мотивации к обучению представим, что вы - Танос. Тот самый, с фиолетовым лицом. Вы очень занятой титан. Вам нужно уничтожить половину Вселенной, в конце концов! Ваш план выглядит примерно следующим образом:

 1. Найти перчатку
 2. Собрать камни бесконечности
 3. Навалять Мстителям
 4. Щелкнуть пальцами
 5. Наконец отдохнуть, любуясь восходом благодарной Вселенной.

Не будем останавливаться на том, с какого перепугу Таносу пришлось писать программу на Python, а сразу перейдем к вопросу - как же вам эти данные хранить?
Можно, конечно, как простую строку:

```python
thanos_awesome_todo_list = """
 1. Найти перчатку
 2. Собрать камни бесконечности
 3. Навалять Мстителям
 4. Щелкнуть пальцами
 5. Наконец отдохнуть, любуясь восходом благодарной Вселенной.
"""
```

> В Python использование тройных кавычек `"""` позволяет задавать строку с переносами.

В таком случае, вывести этот список на экран будет проще простого:
```python
print(thanos_awesome_todo_list)
```

Но вот смотались вы на Нидавеллир, перебили гномов, выковали перчатку и смотрите, и заглядываете в свой список дел, чтобы понять, что же вам делать дальше. И понимаете, что, в общем-то, хранение данных в строке является не очень удобным - пункт из него не вычеркнешь. Надо переназначать переменную. Либо резать строку, добавлять пункт и клеить снова. Неразбериха, в общем. 

Задача осложняется так же и тем, что план может изменяться по ходу выполнения. К примеру, невозможно найти камень Души, не найдя Гамору, которая пошла против вас и скрыла столь важные данные. Так что пункт "Найти Гамору" должен будет стоять перед пунктом "Собрать камни бесконечности". 

Задача исправления плана становится еще более сложной, и вы понимаете, что решение с хранением списка дел в виде строки является совершенно неоптимальным.

А вы стали великим Безумным Титаном не потому, что принимали неоптимальные решения. Так что стоит исправить эту проблему, **структурировав** данные. Сделать так, чтобы их было удобно изменять и использовать. 

Что же первое придет вам в голову?

## Массив

Возможно, спереть Небулу и пытать ее, чтобы Гамора сама вас нашла, тем самым избежав необходимости изменять строку со списком дел, но я не об этом. Я говорю о том, чтобы использовать массивы.

Массив - простейшая структура данных. По сути, это переменная, хранящая вместо одного значения сразу много. Как же это работает, и почему?

Здесь должен был быть большой кусок о том, как память работает на низком уровне, но, пожалуй, я оставлю эту часть на потом, до того момента, когда мы уже пройдемся по основам практики и заглянем в более сложную теорию, необходимую для полноты картины. 

Итак, что же такое массив? 

Как гласит википедия, **массив - это структура данных, хранящая набор значений (элементов массива), идентифицируемых по индексу или набору индексов**. Но вы здесь не для того, чтобы читать выдержки из википедии, так что объясню более образно.

Как вы помните, для объяснения работы переменной я использовал метафору с емкостями. Так вот, массив - это, по сути, стеллаж (полка), хранящий эти самые емкости. Но хранящий определенным образом - **все емкости пронумерованы по порядку и выстроены в порядке возрастания номеров**. Благодаря этому вы в любой момент можете взять емкость с любым номером, если таковая, разумеется, вообще существует. Номер емкости называется **индексом**. Это, по сути, уникальный идентификатор емкости - каждая емкость соответствует своему идентификатору, а каждый идентификатор - своей емкости. Связь один к одному, короче.

Собственно, массив - это переменная, хранящая кучу других пронумерованных переменных, обратиться к которым можно по номеру (индексу).

Массивы - структура данных с ограниченной длиной, так как память под нее выделяется при объявлении. То бишь, если вы, к примеру, в языке java объявите массив длинной в 10 переменных целочисленного типа

```java
int cats[]; 
array = new int[10];
```
, а потом попытаетесь обратиться к элементу этого массива под номером 20

```java
System.out.println(array[20])
```

, вы получите ошибку "выход за пределы диапазона индексов". 

> Операция `[]` позволяет обратиться к элементу массива по его индексу. К примеру, `a[4]` - обращение к элементу массива `a` с индексом 4. 

Если мои пространные объяснения оказались не очень понятными - [здесь](http://developer.alexanderklimov.ru/android/java/array.php) есть замечательное в своей простоте описание того, как работать с массивами в Java и че это такое. Очень советую.

Надеюсь, с тем, что такое массивы, мы разобрались. Как с ними работать в питоне?

А никак, к сожалению, в питоне массивов нет.

Выдержим драматическую паузу, ииии...

...к счастью, в питоне есть куда более удобная штука - список (**list**). В плане возможностей он ощутимо удобнее, чем массив, и при этом является, так сказать, его эволюционным потомком - предоставляет все те же возможности, что предоставлял массив, но при этом еще кучу всего добавляет сверху. 

Вообще, список реализован несколько иначе, нежели массив, но, я думаю, на сегодня теории уже хватит. А базовая инфа по массивам, которую я вам дал, поможет не только в данной теме, но и в дальнейшем.

Итак, как же нам создать список?

```python
a = [3, 1, 2, 4]
```

Список в языке python может хранить переменные абсолютно любого типа. Даже другие списки:

```python
b = [[1, 2, 3], a, [4, 5, 6]]
```

> Список, хранящий другие списки, называется **двумерным списком\массивом**, или **матрицей**. Если же вы засунете в список двумерные списки, то получится трехмерный список. Трехмерные - трехмерный. И так до бесконечности.

Как добавить новый элемент? Очень просто:

```python
a.append(4)
print(a)

[3, 1, 2, 4, 4]
```

Как получить элемент списка? Так же, как и в массиве - по индексу:

```python
print(a[2])

2
```

Изменить элемент списка тоже можно, используя индекс:

```python
a[3] = 5
print(a)

[3, 1, 2, 5, 4]
```

Да, чуть не забыл один важный момент - **индексация в массиве начинается с нуля, а не с единицы**. На данном этапе вы не очень понимаете, на кой хрен это таким образом устроено, но потом, когда я расскажу о том, каким образом работает память, вы поймете всю гениальность затеи. На данный момент же просто запомните, что **в массиве из 10 элементов первый элемент будет иметь индекс 0, последний - индекс 9**. 

Любой список (а так же куча других структур данных в python) имеют такой показатель, как **длина**, получаемый с помощью функции `len()`:

```python
print(len(a))

5
```

Как же пройтись по всем элементам списка? Самый очевидный вариант - создать отдельную переменную, изменять ее в цикле, начиная с 0 и заканчивая длиной массива, и получать доступ к каждой ячейке массива с индексом, равным этой переменной.

К примеру, выведем все элементы нашего списка:

```python
i = 0

while i < len(a):
    print(a[i])
    i+=1
```

Обращение a[i] означает обращение к ячейке массива a с индексом, равным значению переменной i. Для наглядности запустите следующий код, чтобы увидеть соответствие между индексом и ячейкой массива с этим индексом:

```python
i = 0

while i < len(a):
    print('Index: {}, Value: {}'.format(i, a[i]))
    i+=1 
```

Однако python не был бы собой, если бы не предоставил более красивый способ реализовать такую повседневную задачу, как итерация по списку. На помощь в данном случае приходит цикл `for`.

Не стоит путать цикл `for` в python и в других языках. В других цикл for - это пошаговый цикл. Для задачи итерации по списку `a` он выглядел бы следующим образом:

```java
for (int i = 0; i < a.length(); i = i + 1){
    System.out.println(a[i]);
}
```

Цикл for в данном случае на человеческий язык можно перевести следующим образом: *Создай переменную `i`, присвой ей значение ноль, а затем прибавляй к ней по единице, пока она будет меньше длины списка `a`*. То бишь, список for в данном случае - это упрощенная запись цикла while.

В python же цикл for позволяет осуществлять **итерирование** по списку - то бишь, он позволяет пройтись по всем элементам списка, не заморачиваясь такими вещами как индексы, их изменения, длина списка и т.д. и т.п.

Выглядит это следующим образом:

```python
for element in a:
    print(element)
```

Да, вот так просто.

В переводе, опять же, на человеческий, это звучало бы примерно так: *Последовательно бери по элементу из списка `a` и делай с каждым из них то, что написано дальше в данном логическом блоке (в примере - выведи на экран)*.

> Для справедливости стоит заметить, что большинство активно разрабатываемых языков так же ввели возможность итерирования по структурам данных

Для возможности жонглировать списками как нам угодно Python обладает такой замечательной штукой, как **срезы**. Срезы позволяют получать некоторую часть списка. Выглядит это примерно так:

```python
b = [1, 2, 3, 4, 5]
print(b[:4])
print(b[2:])
print(b[2:4])

[1, 2, 3, 4]
[3, 4, 5]
[3, 4]
```

Срезы имеют синтаксис [x:y:step], где x - это индекс элемента, с которого будет начинаться срез, y - индекс элемента, которым срез будет закончен, а step - это шаг, с которым будут выбираться элементы списка. Все эти переменные могут быть опущены (не указаны). X по умолчанию равен 0. y - длине списка, setp - нулю.

Если вы не поняли, нафига нужен step, вот вам пример того, как можно выбрать из списка только четные элементы:

```python
c = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(c[1::2])
```

Начинаем с элемента с индексом 1 (с двойки), берем каждый второй элемент - получаем список всех четных. 

Но вернемся к тому, что вы - Танос, и у вас горит задача по созданию списка дел. Как это сделать с помощью структуры данных "список"? Легче легкого:

```python
thanos_awesome_todo_list = [
    "Найти перчатку",
    "Собрать камни бесконечности",
    "Навалять Мстителям",
    "Щелкнуть пальцами",
    "Наконец отдохнуть, любуясь восходом благодарной Вселенной."
]
```

Как вывести на экран весь список? Вспомним пример с проходом по списку с помощью цикла while:

```python
i = 0
while i < len(thanos_awesome_todo_list):
    print('{}. {}'.format(i+1, thanos_awesome_todo_list[i]))
    i += 1
```

Как вы помните, функция `format()` подставляет в строку вместо `{}` значения переменных, записаных в скобках. В результате выполнения программы получим следующий результат:

```
1. Найти перчатку
2. Собрать камни бесконечности
3. Навалять Мстителям
4. Щелкнуть пальцами
5. Наконец отдохнуть, любуясь восходом благодарной Вселенной.
```

То, что нам и нужно!

Мы так же можем вывести произвольный пункт списка дел (не забываем, что индексация начинается с 0):

```python
print(thanos_awesome_todo_list[3])

Щелкнуть пальцами
```

Если вас, как Безумного Титана, не очень сильно парит необходимость выводить пункты списка дел с номерами, то код можно переписать с использованием цикла for:

```python
for todo in thanos_awesome_todo_list:
    print(todo)
```

Подытожим:

> Массив - специальная переменная (структура данных), которая хранит множество проиндексированных (пронумерованных) переменных

> Обращаться к элементам массива можно по индексу с помощью оператора `[]`

> Элементы массива индексируются, начиная с нуля. Индекс первого элемента массива равен 0, индекс последнего - длине массива минус один.

> В Python вместо массивов используется более продвинутая структура данных - список (list)

> Пройтись по всему циклу можно с помощью цикла while, используя индексы, или цикла for, используя итерирование. 

И, наконец, ответим на вопрос, **зачем вообще нужны массивы?** Массивы нужны тогда, когда у вас есть множество однотипных данных (в основном вы не знаете, сколько именно), и вам нужен удобный способ их хранить и обрабатывать. Такие дела.

С массивами временно закончили, переходим к следующей очень полезной структуре данных.

## Кортеж

Кортеж - тот же список, только неизменяемый. Объявляется вот так:

```python
a = (1, 2)
```

Помимо неизменяемости абсолютно аналогичен списку. Все.

Да, серьезно, все.

Нафига он используется? В основном для возвращения нескольких значений из функции. С ним мы столкнемся чуть ниже, а пока перейдем к словарям.

## Словарь

Словарь используется чуть реже, чем список, но при этом иногда бывает незаменим. В чем разница между списком и словарем? В списке, как вы помните, индексами являлись числа, причем числа эти всегда находятся в диапазоне от 0 до длины списка минус 1. В то же время эти индексы являлись номером элемента списка. Таким образом, обращения к элементу списка производятся с помощью индекса.

Словарь вместо индексов использует **ключи**. Ключ - это какое-либо значение, которое вы насильно делаете идентификатором элемента ключа. 

Проведем аналогию:

Список - это ряд машин, стоящих на пронумерованных местах. Паркуясь и уходя в магаз, вы запоминаете номер места, на котором оставили машину, и, выйдя из магазина, можете снова с легкостью ее найти.

Словарь - это тот же ряд, но места не пронумерованы. А еще, выходя из магазина, вы не паритесь и пикаете автомобильными ключами, на которые отзывается ваш автомобиль. Ключи автомобильные в данной аналогии представляют собой ключ словаря. Каждой машине соответствуют свои ключи, каждым ключам - своя машина, но ключи от машины - это не номер парковочного места (точно так же, как ключ в словаре не является номером элемента)

Разумеется, под капотом эти стркутуры данных кардинально различаются (список является реализацией, собственно, списка, словарь же - хэш-таблицы. Что это такое, объясню в будущих лекциях), однако на том уровне, на котором вы будете их использовать, вам хватит понимания только этой отличительной особенности.

Объявляется пустой словарь следующим образом:

```python
a = {}
```

либо 

```python
a = dict()
```

Для того, чтобы добавить новое значение в словарь, вы как бы говорите ему: *под таким-то ключом я хочу хранить такое-то значение*:

```python
a['key'] = 'value'
```

Говорят, что словарь **хранит пары ключ - значение**. Это значит, что каждому ключу соответствует свое значение, а каждому значению - свой ключ. В записи выше ключом является `'key'`, а значением - '`value`'.

Можно объявить непустой словарь (изначально хранящий ключи и значения):

```python
b = {1: 'a', 2: 'b', 3: 'c'}
```

В этой записи числа являются ключами, буквы - значениями.

Получить данные из словаря можно с помощью ключа, используя тот же оператор, что и для списка - `[]`:

```
print(b[1])
print(b[3])
print(a['key'])

a
b
value
```

Как список может хранить другие списки, так и словарь может хранить другие словари:

```python
c = {
    'a': a,
    'b': b, 
    'new': {'key1': 'value1', 'key2': 'value2'}
}
```

Кстати, для полуения значений списка, хранящемся в другом списке, оператор `[]` используеся два раза подряд:

```python
print(c['new']['key2]')

value2
```

Сперва по ключу `'new'` мы получаем целый словарь, являющийся одним из значений, хранящихся в словаре `c`. Затем с помощью второго оператора `[]` из полученного словаря с помощью ключа `'key2'` мы получаем значение `'value2'` (Точно так же, кстати, извлекается значение из двумерного списка).

Словарь, к слову, может хранить списки:

```python
dict_of_lists = {
    'list1': [1, 2, 3],
    'list2': ['a', 'b', 'c']
}
```

а список - словари:

```python
list_of_dicts = [
    {1: 'a', 2: 'b'},
    {'c': 1, 'd': 2}
]
```

Теперь мы уже больше знаем о том, как пользоваться словарями. Но предположим следующую ситуацию - у нас есть словарь с неизвестным содержанием (мы не знаем ни ключей, хранящихся в нем, ни значенией), но нам нужно вывести все его содержание. Как получить доступ к данным, если мы не знаем ключей, хранимых в словаре?

К счастью, есть способ получить все ключи словаря. А точнее, **список ключей**:

```python
d = {'key1': 'value1', 'key2': 'value2'}
print(d.keys())

dict_keys(['key1', 'key2'])
```

Вернуло нам список ключей с типом dict_keys, который, в общем-то, не совсем список (индексацию не поддерживает, мудак такой). Но мы можем превратить его в список, воспользовавшись функцией `list()`:

```python
d = {'key1': 'value1', 'key2': 'value2'}
print(list(d.keys()))

['key1', 'key2']
```

Вот, так-то лучше. Хотя это и не ответило на вопрос "каким хреном это поможет нам итерироваться по списку?" А я отвечу следующим образом.

Мы получили список ключей. Мы можем итерироваться по всему списку ключей, чтобы получать ключи по отдельности, и получать данные из словаря, используя эти ключи.

Если не поняли, что я сказал - вот вам код, тут понятнее:

```python
# вот наш список
d = {'key1': 'value1', 'key2': 'value2'}

# мы получаем список ключей
keys = list(d.keys())

i = 0
# проходимся по всему списку ключей
while i<len(keys):
    # берем ключи по одному
    key = keys[i]
    # получаем значение по ключу
    value = d[key]
    # выводим пару ключ-значение
    print('Ключ: {}, Значение: {}'.format(key, value))

    i+=1
```

В результате работы программы мы получим следующее:

```
Ключ: key1, Значение: value1
Ключ: key2, Значение: value2
```

Поздравляю, вы великолепны!

Но, как я уже много раз говорил, python не был бы собой, если бы не облегчал все подряд. Так и итерацию по словарю можно упросить с помощью функции `items()`. Что она делает? Посмотрим:

```python
print(d.items())
```

и получим в ответ:

```
dict_items([('key1', 'value1'), ('key2', 'value2')])
```

Данная функция возвращает список из пар ключ-значение в виде кортежей. То бишь, код для получения пар ключ-значения выше можно переписать следующим образом:

```python
for key_value_pair in d:
    print('Ключ: {}, Значение: {}'.format(key_value_pair[0], key_value_pair[1]))
```

или, еще проще 

```python
for key, value in d:
    print('Ключ: {}, Значение: {}'.format(key, value))
```

Удивительно удобно!

# Вместо заключения

На этом пока все. Голова у меня, если честно, после рабочей недели не варит вообще, поэтому поиграйтесь пока со списками, кортежами и словарями, домашка будет завтра в слэке. Хочется придумать ченить интересное. До завтра, в общем.